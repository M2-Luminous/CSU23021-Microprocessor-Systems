
#include <stdio.h>
#include <stdlib.h>

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "lab09.pio.h"
#include "hardware/adc.h"

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to



// Initialise a GPIO pin – see SDK for detail on gpio_init()
void asm_gpio_init(uint pin) {
    gpio_init(pin);
}

// Set direction of a GPIO pin – see SDK for detail on gpio_set_dir()
void asm_gpio_set_dir(uint pin, bool out) {
    gpio_set_dir(pin, out);
}

// Get the value of a GPIO pin – see SDK for detail on gpio_get()
bool asm_gpio_get(uint pin) {
    return gpio_get(pin);
}

// Set the value of a GPIO pin – see SDK for detail on gpio_put()
void asm_gpio_put(uint pin, bool value) {
    gpio_put(pin, value);
}

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}


/**
 * @brief LAB #09 - TEMPLATE
 *        Main entry point for the code - calls the main assembly
 *        function where the body of the code is implemented.
 * 
 * @return int      Returns exit-status zero on completion.
 */

static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}

int loop=0;
int temperature (uint32_t rawADC){
    
    float temp= 437 - (100*(float)( rawADC)) / 215;
    printf("Raw Temperature is = %u\n",rawADC);
    char tempstring[5];
    itoa(temp, tempstring, 10);
    printf("Fixed Temperature is = %s\n",tempstring);
     
    //stdio_init_all();
    //
    // Configure ADC
    //adc_init();
    //adc_set_temp_sensor_enabled(true);
    //adc_select_input(4);
    //
    // Primary Core 0 Loop
    //uint16_t raw = adc_read();
    //const float conversion_factor = 3.3f / (1<<12);
    //float result = raw * conversion_factor;
    //float tmp = 27 - (result -0.706)/0.001721;
    //printf("Temp = %f C\n", tmp);

    if( loop==0){
        PIO pio = pio0;
        uint offset = pio_add_program(pio, &ws2812_program);
        ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);
    }
    if (temp>=20){
        put_pixel(urgb_u32(0x3F, 0x00, 0x00));
        
     } else if (temp<20&&temp>=19) {
            // temperature is orange
        put_pixel(urgb_u32(255, 191, 0));
       
        
     }else {
            //set led to blue for cold
             put_pixel(urgb_u32(0x00, 0x00, 0x3F));
            
      
        }
loop=1;
    return 0;
}

// Must declare the main assembly entry point before use.
void main_asm();

/**
 * @brief EXAMPLE - WS2812_RGB
 *        Simple example to initialise the NeoPixel RGB LED on
 *        the MAKER-PI-PICO and then flash it in alternating
 *        colours between red, green and blue forever using
 *        one of the RP2040 built-in PIO controllers.
 * 
 * @return int  Application return code (zero for success).
 */
int main() {
 
    // Initialise all STDIO as we will be using the GPIOs
    stdio_init_all();
    
    
    // Initialise the PIO interface with the WS2812 code
    PIO pio = pio0;
    uint offset = pio_add_program(pio, &ws2812_program);
    ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);

    //intialised led as red
    put_pixel(urgb_u32(0x3F, 0x00, 0x00));
    sleep_ms(500);
    
     main_asm();
    
    while(true) {
    }

    // Should never get here due to infinite while-loop.
    return 0;

}
